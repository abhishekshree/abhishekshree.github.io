{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Clean code\"), \" is all right but pretty overused by now. Simplification coming at the cost of degraded performance should never be a choice (sorry python fans). Testable chunks of code carry way too much importance. Your code can be however you like in my opinion if there is a test suite explaining all what the particular module covers. \"), mdx(\"p\", null, \"Readability, as Churchill said of courage, is rightly esteemed the first of qualities, because it is the quality which guarantees all others.\"), mdx(\"p\", null, \"Who's arguing for unreadable code? Not me, but there seems to be a lot of it around, all the same. It's not that anyone deliberately sets out to write unreadable code, of course; it just ends up that way because we mistakenly prioritise other virtues over readability. Performance is one such virtue, and there are cases where performance genuinely matters.\"), mdx(\"p\", null, \"Anyway, that's about being CRISP. Moving to generics, it has been a while since I have been dabbling into \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://abhishekshree.github.io/blog/lambda-calculus\"\n  }, \"lambda calculus\"), \" and functional programming. The more I see myself applying such ideas to day to day work, the more sensible it seem to me. Generics are an example of the same.\"), mdx(\"p\", null, \"So I had a situation wherein I was supposed to use an SQL connector and a bunch of select queries to populate a list which was then compared to a different list (yeah think of it being something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git diff\"), \"). Now initially I ended up using something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db *sql.DB\"), \" like everyone does, save all the query result in an array, did index based comparison after that and get the results.\"), mdx(\"p\", null, \"This worked, but it sucked at a lot of levels, first, no one would agree that my logic works under all circumstances. Why? The module lacked tests. I wrote the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SELECT\"), \" query knowing that it would work that way given the schema, but explaining that to people is tough, which makes sense as well, if they were to sit and understand whatever I am up to why not do it themselves in probably lesser time. Okay, time to write tests, ah shit you see the trouble? \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db *sql.DB\"), \". Now do I create an in memory db, change the connection string and then write tests for my function? No that's too ugly, might as well test in prod. \"), mdx(\"p\", null, \"Read about this a bit, and came across the use of a widely famous design pattern, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://refactoring.guru/design-patterns/adapter\"\n  }, \"Adapter Pattern\"), \" which was a bliss, changing the direct database pointer to an abstract (generic) store with similar features as the ORM was pretty interesting to ponder about. Even came up with a few optimizations in the way I was \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SELECT\"), \"ing.\"), mdx(\"p\", null, \"Moving on, the huge list, now it is to bad that tuple like data structures cannot be compared directly, which makes sense as well. But that was no reason for me to put everything in a list and then compare the indexes. To improve that, I ended up implementing a generic data structure with one indexable entry which has partial order implemented. This helped me to shift the comparison right while saving it in memory and always maintain a fixed index to access it in O(1).\"), mdx(\"p\", null, \"Think of it as something like:\"), mdx(\"pre\", {\n    \"className\": \"language-go\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"type\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"Structure\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"type\"), \" T comparable\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"map\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"[\"), \"T\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"int\"), \"\\n\")), mdx(\"p\", null, \"Implementing operations on this improved upon the logic and in turn the execution time of the whole package exponentially (not going into details but we are talking about 1000x improvement). This was a pretty interesting experience. You should also, at times, try playing with the math being the mundane tasks like these. I mean I ended up storing this structure in the same structure definition generic and it was all proven pretty systematically, which was pretty cool tbh.\"), mdx(\"p\", null, \"Anyway, if you want more about generics a bit more \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.ploeh.dk/2018/03/22/functors/\"\n  }, \"consider visiting here\"), \".\"), mdx(\"p\", null, \"Cheers!\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p><em>Clean code</em> is all right but pretty overused by now. Simplification coming at the cost of degraded performance should never be a choice (sorry python fans). Testable chunks of code carry way too much importance. Your code can be however you like in my opinion if there is a test suite explaining all what the particular module covers. </p><p>Readability, as Churchill said of courage, is rightly esteemed the first of qualities, because it is the quality which guarantees all others.</p><p>Who&#x27;s arguing for unreadable code? Not me, but there seems to be a lot of it around, all the same. It&#x27;s not that anyone deliberately sets out to write unreadable code, of course; it just ends up that way because we mistakenly prioritise other virtues over readability. Performance is one such virtue, and there are cases where performance genuinely matters.</p><p>Anyway, that&#x27;s about being CRISP. Moving to generics, it has been a while since I have been dabbling into <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://abhishekshree.github.io/blog/lambda-calculus\">lambda calculus</a> and functional programming. The more I see myself applying such ideas to day to day work, the more sensible it seem to me. Generics are an example of the same.</p><p>So I had a situation wherein I was supposed to use an SQL connector and a bunch of select queries to populate a list which was then compared to a different list (yeah think of it being something like <code>git diff</code>). Now initially I ended up using something like <code>db *sql.DB</code> like everyone does, save all the query result in an array, did index based comparison after that and get the results.</p><p>This worked, but it sucked at a lot of levels, first, no one would agree that my logic works under all circumstances. Why? The module lacked tests. I wrote the <code>SELECT</code> query knowing that it would work that way given the schema, but explaining that to people is tough, which makes sense as well, if they were to sit and understand whatever I am up to why not do it themselves in probably lesser time. Okay, time to write tests, ah shit you see the trouble? <code>db *sql.DB</code>. Now do I create an in memory db, change the connection string and then write tests for my function? No that&#x27;s too ugly, might as well test in prod. </p><p>Read about this a bit, and came across the use of a widely famous design pattern, the <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://refactoring.guru/design-patterns/adapter\">Adapter Pattern</a> which was a bliss, changing the direct database pointer to an abstract (generic) store with similar features as the ORM was pretty interesting to ponder about. Even came up with a few optimizations in the way I was <code>SELECT</code>ing.</p><p>Moving on, the huge list, now it is to bad that tuple like data structures cannot be compared directly, which makes sense as well. But that was no reason for me to put everything in a list and then compare the indexes. To improve that, I ended up implementing a generic data structure with one indexable entry which has partial order implemented. This helped me to shift the comparison right while saving it in memory and always maintain a fixed index to access it in O(1).</p><p>Think of it as something like:</p><pre class=\"language-go\"><code class=\"language-go\"><span class=\"text-code-purple\">type</span> <span class=\"text-code-blue\">Structure</span><span class=\"text-code-white\">(</span><span class=\"text-code-purple\">type</span> T comparable<span class=\"text-code-white\">)</span> <span class=\"text-code-purple\">map</span><span class=\"text-code-white\">[</span>T<span class=\"text-code-white\">]</span><span class=\"\">int</span>\n</code></pre><p>Implementing operations on this improved upon the logic and in turn the execution time of the whole package exponentially (not going into details but we are talking about 1000x improvement). This was a pretty interesting experience. You should also, at times, try playing with the math being the mundane tasks like these. I mean I ended up storing this structure in the same structure definition generic and it was all proven pretty systematically, which was pretty cool tbh.</p><p>Anyway, if you want more about generics a bit more <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://blog.ploeh.dk/2018/03/22/functors/\">consider visiting here</a>.</p><p>Cheers!</p>","scope":{}},"frontMatter":{"wordCount":630,"readingTime":{"text":"4 min read","minutes":3.145,"time":188700,"words":629},"slug":"generics-and-code-correctness","fileName":"generics-and-code-correctness.mdx","title":"Generics and code correctness","date":"2023-07-05","tags":[],"draft":false,"summary":"Summarizing how generics and abstractions help in explainability of code","images":[]}},"prev":{"title":"TIL - Binaries are weird","date":"2023-07-04","tags":["linux","binaries","til"],"draft":false,"summary":"Wanted to know why are binaries for the same program of variable size and what optimizations follow.","images":[],"slug":"tilbinaries"},"next":null},"__N_SSG":true}