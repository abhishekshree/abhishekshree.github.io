{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So I was deep into Kubernetes this weekend, trying to wrap my head around pods and services, when it hit me - this is just ROS with different names. If you don't know ROS, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://abhishekshree.github.io/blog/ros-a-primer\"\n  }, \"look here, if \"), \", if you dont know Kubernetes, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://abhishekshree.github.io/blog/kubernetes-a-primer\"\n  }, \"look here\"), \".\"), mdx(\"p\", null, \"I found it strikingly similar how both systems approach the same core problem: orchestrating a bunch of independent processes without everything falling apart. The more I thought about it, the more fascinating this parallel became.\"), mdx(\"h1\", {\n    \"id\": \"twins-fr\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#twins-fr\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Twins fr\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ROS Master = Kubernetes API Server\"), \"\\nThe ROS Master acts like DNS for your robot nodes - it tracks who's publishing what and who needs to subscribe to what. The Kubernetes API server does exactly the same thing for containers, maintaining the cluster state and handling service discovery.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Nodes = Pods\"), \"\\nA ROS node is an independent process that does one thing well. A Kubernetes pod is... an independent process (or group of tightly coupled processes) that does one thing well. Both are the fundamental unit of computation in their respective systems.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Topics = Services\"), \"\\nROS topics provide publish-subscribe messaging between nodes. Kubernetes services provide networking abstraction between pods. Different implementation, same concept - decoupled communication.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parameter Server = ConfigMaps/Secrets\"), \"\\nBoth systems need a way to share configuration. ROS uses the Parameter Server as a shared dictionary. Kubernetes uses ConfigMaps and Secrets. Same pattern, different names.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Launch Files = Manifests\"), \"\\nWant to start multiple ROS nodes with specific configurations? Write a launch file. Want to deploy multiple Kubernetes resources? Write YAML manifests. Both are declarative ways to describe your desired system state.\"), mdx(\"h1\", {\n    \"id\": \"the-orchestration-magic\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#the-orchestration-magic\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"The Orchestration Magic\"), mdx(\"p\", null, \"Here's where it gets interesting. Both systems are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"declarative\"), \" - you tell them what you want, not how to get there.\"), mdx(\"p\", null, \"In ROS, you don't manually start nodes and wire up topics. You declare your system in launch files and let ROS figure out the startup order and communication paths.\\nWith Kubernetes, you don't manually start containers and configure networking. You declare your desired state in manifests and let Kubernetes figure out scheduling, networking, and health management.\"), mdx(\"p\", null, \"Both systems also handle \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"failure gracefully\"), \". If a ROS node crashes, other nodes can detect the failure and potentially restart or replace it. If a pod crashes, Kubernetes automatically restarts it or spins up replacements.\"), mdx(\"h1\", {\n    \"id\": \"where-they-diverge\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#where-they-diverge\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Where They Diverge\"), mdx(\"p\", null, \"ROS assumes everything runs on the same network (though \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.yahboom.net/public/upload/upload-html/1747127709/16.ROS2%20distributed%20communication.html\"\n  }, \"ROS 2 is changing this\"), \", wish I had the chance to work on it someday). Kubernetes assumes everything might be distributed across multiple machines.\"), mdx(\"p\", null, \"ROS is real-time focused - your robot control loop can't afford 100ms latencies (launghs in the barrel roll attempt \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=jmPLSV7gSB0\"\n  }, \"we did in 2024\"), \"). Kubernetes prioritizes resilience and scalability over absolute performance.\"), mdx(\"p\", null, \"ROS has specialized tools for robotics (tf for coordinate transforms, URDF for robot descriptions), jokes on k8s.\"), mdx(\"p\", null, \"If you understand ROS, Kubernetes concepts should feel familiar. Both are solving the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"distributed systems coordination problem\"), \" - they just happen to be optimized for different domains.\"), mdx(\"p\", null, \"The mental model transfers beautifully. Instead of thinking about Kubernetes as some mysterious cloud thing, think of it as ROS for web applications. Instead of roscore, you have the API server. Instead of rostopic, you have kubectl. All of this might be useful, or just a 3AM thought. \"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>So I was deep into Kubernetes this weekend, trying to wrap my head around pods and services, when it hit me - this is just ROS with different names. If you don&#x27;t know ROS, <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://abhishekshree.github.io/blog/ros-a-primer\">look here, if </a>, if you dont know Kubernetes, <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://abhishekshree.github.io/blog/kubernetes-a-primer\">look here</a>.</p><p>I found it strikingly similar how both systems approach the same core problem: orchestrating a bunch of independent processes without everything falling apart. The more I thought about it, the more fascinating this parallel became.</p><h1 id=\"twins-fr\"><a href=\"#twins-fr\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Twins fr</h1><p><strong>ROS Master = Kubernetes API Server</strong>\nThe ROS Master acts like DNS for your robot nodes - it tracks who&#x27;s publishing what and who needs to subscribe to what. The Kubernetes API server does exactly the same thing for containers, maintaining the cluster state and handling service discovery.</p><p><strong>Nodes = Pods</strong>\nA ROS node is an independent process that does one thing well. A Kubernetes pod is... an independent process (or group of tightly coupled processes) that does one thing well. Both are the fundamental unit of computation in their respective systems.</p><p><strong>Topics = Services</strong>\nROS topics provide publish-subscribe messaging between nodes. Kubernetes services provide networking abstraction between pods. Different implementation, same concept - decoupled communication.</p><p><strong>Parameter Server = ConfigMaps/Secrets</strong>\nBoth systems need a way to share configuration. ROS uses the Parameter Server as a shared dictionary. Kubernetes uses ConfigMaps and Secrets. Same pattern, different names.</p><p><strong>Launch Files = Manifests</strong>\nWant to start multiple ROS nodes with specific configurations? Write a launch file. Want to deploy multiple Kubernetes resources? Write YAML manifests. Both are declarative ways to describe your desired system state.</p><h1 id=\"the-orchestration-magic\"><a href=\"#the-orchestration-magic\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>The Orchestration Magic</h1><p>Here&#x27;s where it gets interesting. Both systems are <strong>declarative</strong> - you tell them what you want, not how to get there.</p><p>In ROS, you don&#x27;t manually start nodes and wire up topics. You declare your system in launch files and let ROS figure out the startup order and communication paths.\nWith Kubernetes, you don&#x27;t manually start containers and configure networking. You declare your desired state in manifests and let Kubernetes figure out scheduling, networking, and health management.</p><p>Both systems also handle <strong>failure gracefully</strong>. If a ROS node crashes, other nodes can detect the failure and potentially restart or replace it. If a pod crashes, Kubernetes automatically restarts it or spins up replacements.</p><h1 id=\"where-they-diverge\"><a href=\"#where-they-diverge\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Where They Diverge</h1><p>ROS assumes everything runs on the same network (though <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://www.yahboom.net/public/upload/upload-html/1747127709/16.ROS2%20distributed%20communication.html\">ROS 2 is changing this</a>, wish I had the chance to work on it someday). Kubernetes assumes everything might be distributed across multiple machines.</p><p>ROS is real-time focused - your robot control loop can&#x27;t afford 100ms latencies (launghs in the barrel roll attempt <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://www.youtube.com/watch?v=jmPLSV7gSB0\">we did in 2024</a>). Kubernetes prioritizes resilience and scalability over absolute performance.</p><p>ROS has specialized tools for robotics (tf for coordinate transforms, URDF for robot descriptions), jokes on k8s.</p><p>If you understand ROS, Kubernetes concepts should feel familiar. Both are solving the <strong>distributed systems coordination problem</strong> - they just happen to be optimized for different domains.</p><p>The mental model transfers beautifully. Instead of thinking about Kubernetes as some mysterious cloud thing, think of it as ROS for web applications. Instead of roscore, you have the API server. Instead of rostopic, you have kubectl. All of this might be useful, or just a 3AM thought. </p>","scope":{}},"frontMatter":{"wordCount":543,"readingTime":{"text":"3 min read","minutes":2.705,"time":162300,"words":541},"slug":"ros-and-k8s","fileName":"ros-and-k8s.md","title":"Kubernetes and ROS are surprisingly similar","date":"2025-06-29","tags":["kubernetes","ROS","distributed systems"],"draft":false,"summary":"Why learning ROS made Kubernetes click for me.","images":[]}},"prev":{"title":"Endnotes","date":"2024-06-09","tags":["IITK"],"draft":false,"summary":"My take as I leave?","images":[],"slug":"endnotes"},"next":{"title":"Kubernetes, EKS and some Karpenter(y)","date":"2025-06-29","tags":["kubernetes","aws","eks","karpenter","devops"],"draft":false,"summary":"From container chaos to cluster harmony - understanding K8s, EKS flavors, and why Karpenter even exists.","images":[],"slug":"kubernetes-a-primer"}},"__N_SSG":true}