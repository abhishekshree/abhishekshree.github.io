{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It is almost fascinating to imagine how neatly go implements its co-routines based feature, goroutines. They're not threads unlike Java and C++ (although you can do anything here), but flexible stack (starting from 4K) based execution units. How does that even work? Dug in for a while a found out that it is based on a very prominent paper by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf\"\n  }, \"Hoarre\"), \".\"), mdx(\"h2\", {\n    \"id\": \"the-scheduler\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#the-scheduler\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"The scheduler\"), mdx(\"p\", null, \"Go's scheduler is implemented as 3 structs in C, G, M and P, wherein a goroutines exists only in the virtual space of go runtime and not in the OS.\"), mdx(\"p\", null, \"A \\u201CG\\u201D is simply a goroutine. It\\u2019s represented by type g. When a goroutine exits, its g object is returned to a pool of free gs and can later be reused for some other goroutine.\"), mdx(\"p\", null, \"An \\u201CM\\u201D is an OS thread that can be executing user Go code, runtime code, a system call, or be idle. It\\u2019s represented by type m. There can be any number of Ms at a time since any number of threads may be blocked in system calls.\"), mdx(\"p\", null, \"Finally, a \\u201CP\\u201D represents the resources required to execute user Go code, such as scheduler and memory allocator state. It\\u2019s represented by type p. There are exactly GOMAXPROCS Ps. A P can be thought of like a CPU in the OS scheduler and the contents of the p type like per-CPU state. This is a good place to put state that needs to be sharded for efficiency, but doesn\\u2019t need to be per-thread or per-goroutine.\"), mdx(\"p\", null, \"The scheduler\\u2019s job is to match up a G (the code to execute), an M (where to execute it), and a P (the rights and resources to execute it). When an M stops executing user Go code, for example by entering a system call, it returns its P to the idle P pool. In order to resume executing user Go code, for example on return from a system call, it must acquire a P from the idle pool.\"), mdx(\"p\", null, \"All g, m, and p objects are heap allocated, but are never freed, so their memory remains type stable. As a result, the runtime can avoid write barriers in the depths of the scheduler.\"), mdx(\"h2\", {\n    \"id\": \"blocking\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#blocking\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Blocking\"), mdx(\"p\", null, \"If a goroutine blocks on system call, it blocks it\\u2019s running thread. But another thread is taken from the waiting queue of Scheduler (the Sched struct) and used for other runnable goroutines.\"), mdx(\"p\", null, \"However, if you communicate using channels in go which exists only in virtual space, the OS doesn\\u2019t block the thread. Such goroutines simply go in the waiting state and other runnable goroutine (from the M struct) is scheduled in it\\u2019s place. Don't communicate by sharing memory, share memory by communicating.\"), mdx(\"p\", null, \"The go runtime scheduler also does cooperative scheduling, which means another goroutine will only be scheduled if the current one is blocking or done. This is so much better than pre-emptive scheduling which uses timely system interrupts to block and schedule a new thread as that may lead a task to take longer than needed to finish when number of threads increases, etc. Found the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www1.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf\"\n  }, \"section 6.1\"), \" pretty interesting.\"), mdx(\"h2\", {\n    \"id\": \"sidenote\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#sidenote\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Sidenote\"), mdx(\"p\", null, \"You can also check out some amazing illustrations on concurrency pattern over \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://divan.dev/posts/go_concurrency_visualize/\"\n  }, \"here\"), \".\"), mdx(\"h3\", {\n    \"id\": \"cppgo\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#cppgo\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"cppgo\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/rachit95arora/cppgo\"\n  }, \"This\"), \" repo caught eye when someone questioned whether I can query an array via uncontrolled threads effectively and fast. Implementing a goroutine can help in accessing thread-safe hashmaps so much effectively in my opinion. Here's a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://news.ycombinator.com/item?id=13860962\"\n  }, \"debate\"), \" on that.\"), mdx(\"p\", null, \"Although what was implemented looked like this later on:\"), mdx(\"pre\", {\n    \"className\": \"language-cpp\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"template\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"<\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"typename\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"Key\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"typename\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"Value\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \">\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"class\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"Channel\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"{\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"public\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \":\"), \"\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"void\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"send\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), \"Key key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \",\"), \" Value value\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"{\"), \"\\n        std\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"::\"), \"lock_guard\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"<\"), \"std\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"::\"), \"mutex\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \">\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"lock\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), \"mutex\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n        data\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"[\"), \"key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"=\"), \" value\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n        cv\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"notify_all\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"}\"), \"\\n\\n    Value \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"receive\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), \"Key key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"{\"), \"\\n        std\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"::\"), \"unique_lock\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"<\"), \"std\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"::\"), \"mutex\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \">\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"lock\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), \"mutex\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n        cv\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"wait\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), \"lock\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \",\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"[\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"this\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \",\"), \" key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"]\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"{\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"return\"), \" data\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"find\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), \"key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"!=\"), \" data\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"end\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"}\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n        Value value \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"=\"), \" data\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"[\"), \"key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"]\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n        data\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \".\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-blue\"\n  }, \"erase\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"(\"), \"key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n        \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"return\"), \" value\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n    \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"}\"), \"\\n\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-purple\"\n  }, \"private\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \":\"), \"\\n    std\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"::\"), \"unordered_map\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"<\"), \"Key\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \",\"), \" Value\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \">\"), \" data\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n    std\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"::\"), \"mutex mutex\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n    std\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"\"\n  }, \"::\"), \"condition_variable cv\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \"}\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"text-code-white\"\n  }, \";\"), \"\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>It is almost fascinating to imagine how neatly go implements its co-routines based feature, goroutines. They&#x27;re not threads unlike Java and C++ (although you can do anything here), but flexible stack (starting from 4K) based execution units. How does that even work? Dug in for a while a found out that it is based on a very prominent paper by <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf\">Hoarre</a>.</p><h2 id=\"the-scheduler\"><a href=\"#the-scheduler\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>The scheduler</h2><p>Go&#x27;s scheduler is implemented as 3 structs in C, G, M and P, wherein a goroutines exists only in the virtual space of go runtime and not in the OS.</p><p>A “G” is simply a goroutine. It’s represented by type g. When a goroutine exits, its g object is returned to a pool of free gs and can later be reused for some other goroutine.</p><p>An “M” is an OS thread that can be executing user Go code, runtime code, a system call, or be idle. It’s represented by type m. There can be any number of Ms at a time since any number of threads may be blocked in system calls.</p><p>Finally, a “P” represents the resources required to execute user Go code, such as scheduler and memory allocator state. It’s represented by type p. There are exactly GOMAXPROCS Ps. A P can be thought of like a CPU in the OS scheduler and the contents of the p type like per-CPU state. This is a good place to put state that needs to be sharded for efficiency, but doesn’t need to be per-thread or per-goroutine.</p><p>The scheduler’s job is to match up a G (the code to execute), an M (where to execute it), and a P (the rights and resources to execute it). When an M stops executing user Go code, for example by entering a system call, it returns its P to the idle P pool. In order to resume executing user Go code, for example on return from a system call, it must acquire a P from the idle pool.</p><p>All g, m, and p objects are heap allocated, but are never freed, so their memory remains type stable. As a result, the runtime can avoid write barriers in the depths of the scheduler.</p><h2 id=\"blocking\"><a href=\"#blocking\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Blocking</h2><p>If a goroutine blocks on system call, it blocks it’s running thread. But another thread is taken from the waiting queue of Scheduler (the Sched struct) and used for other runnable goroutines.</p><p>However, if you communicate using channels in go which exists only in virtual space, the OS doesn’t block the thread. Such goroutines simply go in the waiting state and other runnable goroutine (from the M struct) is scheduled in it’s place. Don&#x27;t communicate by sharing memory, share memory by communicating.</p><p>The go runtime scheduler also does cooperative scheduling, which means another goroutine will only be scheduled if the current one is blocking or done. This is so much better than pre-emptive scheduling which uses timely system interrupts to block and schedule a new thread as that may lead a task to take longer than needed to finish when number of threads increases, etc. Found the <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"http://www1.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf\">section 6.1</a> pretty interesting.</p><h2 id=\"sidenote\"><a href=\"#sidenote\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Sidenote</h2><p>You can also check out some amazing illustrations on concurrency pattern over <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://divan.dev/posts/go_concurrency_visualize/\">here</a>.</p><h3 id=\"cppgo\"><a href=\"#cppgo\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>cppgo</h3><p><a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://github.com/rachit95arora/cppgo\">This</a> repo caught eye when someone questioned whether I can query an array via uncontrolled threads effectively and fast. Implementing a goroutine can help in accessing thread-safe hashmaps so much effectively in my opinion. Here&#x27;s a <a target=\"_blank\" rel=\"noopener noreferrer\" style=\"text-decoration:none\" href=\"https://news.ycombinator.com/item?id=13860962\">debate</a> on that.</p><p>Although what was implemented looked like this later on:</p><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"text-code-purple\">template</span> <span class=\"\">&lt;</span><span class=\"text-code-purple\">typename</span> <span class=\"\">Key</span><span class=\"text-code-white\">,</span> <span class=\"text-code-purple\">typename</span> <span class=\"\">Value</span><span class=\"\">&gt;</span>\n<span class=\"text-code-purple\">class</span> <span class=\"\">Channel</span> <span class=\"text-code-white\">{</span>\n<span class=\"text-code-purple\">public</span><span class=\"\">:</span>\n    <span class=\"text-code-purple\">void</span> <span class=\"text-code-blue\">send</span><span class=\"text-code-white\">(</span>Key key<span class=\"text-code-white\">,</span> Value value<span class=\"text-code-white\">)</span> <span class=\"text-code-white\">{</span>\n        std<span class=\"\">::</span>lock_guard<span class=\"\">&lt;</span>std<span class=\"\">::</span>mutex<span class=\"\">&gt;</span> <span class=\"text-code-blue\">lock</span><span class=\"text-code-white\">(</span>mutex<span class=\"text-code-white\">)</span><span class=\"text-code-white\">;</span>\n        data<span class=\"text-code-white\">[</span>key<span class=\"text-code-white\">]</span> <span class=\"\">=</span> value<span class=\"text-code-white\">;</span>\n        cv<span class=\"text-code-white\">.</span><span class=\"text-code-blue\">notify_all</span><span class=\"text-code-white\">(</span><span class=\"text-code-white\">)</span><span class=\"text-code-white\">;</span>\n    <span class=\"text-code-white\">}</span>\n\n    Value <span class=\"text-code-blue\">receive</span><span class=\"text-code-white\">(</span>Key key<span class=\"text-code-white\">)</span> <span class=\"text-code-white\">{</span>\n        std<span class=\"\">::</span>unique_lock<span class=\"\">&lt;</span>std<span class=\"\">::</span>mutex<span class=\"\">&gt;</span> <span class=\"text-code-blue\">lock</span><span class=\"text-code-white\">(</span>mutex<span class=\"text-code-white\">)</span><span class=\"text-code-white\">;</span>\n        cv<span class=\"text-code-white\">.</span><span class=\"text-code-blue\">wait</span><span class=\"text-code-white\">(</span>lock<span class=\"text-code-white\">,</span> <span class=\"text-code-white\">[</span><span class=\"text-code-purple\">this</span><span class=\"text-code-white\">,</span> key<span class=\"text-code-white\">]</span> <span class=\"text-code-white\">{</span> <span class=\"text-code-purple\">return</span> data<span class=\"text-code-white\">.</span><span class=\"text-code-blue\">find</span><span class=\"text-code-white\">(</span>key<span class=\"text-code-white\">)</span> <span class=\"\">!=</span> data<span class=\"text-code-white\">.</span><span class=\"text-code-blue\">end</span><span class=\"text-code-white\">(</span><span class=\"text-code-white\">)</span><span class=\"text-code-white\">;</span> <span class=\"text-code-white\">}</span><span class=\"text-code-white\">)</span><span class=\"text-code-white\">;</span>\n        Value value <span class=\"\">=</span> data<span class=\"text-code-white\">[</span>key<span class=\"text-code-white\">]</span><span class=\"text-code-white\">;</span>\n        data<span class=\"text-code-white\">.</span><span class=\"text-code-blue\">erase</span><span class=\"text-code-white\">(</span>key<span class=\"text-code-white\">)</span><span class=\"text-code-white\">;</span>\n        <span class=\"text-code-purple\">return</span> value<span class=\"text-code-white\">;</span>\n    <span class=\"text-code-white\">}</span>\n\n<span class=\"text-code-purple\">private</span><span class=\"\">:</span>\n    std<span class=\"\">::</span>unordered_map<span class=\"\">&lt;</span>Key<span class=\"text-code-white\">,</span> Value<span class=\"\">&gt;</span> data<span class=\"text-code-white\">;</span>\n    std<span class=\"\">::</span>mutex mutex<span class=\"text-code-white\">;</span>\n    std<span class=\"\">::</span>condition_variable cv<span class=\"text-code-white\">;</span>\n<span class=\"text-code-white\">}</span><span class=\"text-code-white\">;</span>\n</code></pre>","scope":{}},"frontMatter":{"wordCount":638,"readingTime":{"text":"4 min read","minutes":3.185,"time":191100,"words":637},"slug":"goroutines","fileName":"goroutines.mdx","title":"Lightweight threads and concurrency","date":"2023-10-14","tags":["go","linux"],"draft":false,"summary":"A bit about what goroutines actually are.","images":[]}},"prev":{"title":"Could it be any wiser?","date":"2023-07-11","tags":["software"],"draft":false,"summary":"A word for everyone who is here measuring work quality.","images":[],"slug":"could-it-be-any-wiser"},"next":null},"__N_SSG":true}