{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This started with me finding a really fast \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grep\"), \" statement, as I needed to go through a large filesystem (huge, actually) and find certain kinds of malicious files. Turned out with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ripgrep\"), \" it was just as easy as any standard \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grep\"), \" statement, whereas, if I'd choose to go the standard \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grep\"), \" route, it'd be some chained command with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"awk\"), \" and a whole lot of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"regex\"), \".\"), mdx(\"p\", null, \"Anyways, you can also get started the switch to using (and appreciating) Rust CLI tools, 10/10 recommended. Here's a list of some of the ones I've used and liked:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ripgrep\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"grep\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fd\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"find\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"exa\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ls\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"bat\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cat\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"procs\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ps\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"du-dust\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"du\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"hexyl\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"hexdump\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"hyperfine\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"time\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tokei\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"wc\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sd\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sed\"), \" (not so awesome yet though)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"delta\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"diff\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"broot\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tree\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"zoxide\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cd\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"zoom\"), \" <- \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"less\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"grex\"), \" <- For regex stuff\")), mdx(\"p\", null, \"Would update this list as I find more.\"), mdx(\"p\", null, \"Cheers!\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>This started with me finding a really fast <code>grep</code> statement, as I needed to go through a large filesystem (huge, actually) and find certain kinds of malicious files. Turned out with <code>ripgrep</code> it was just as easy as any standard <code>grep</code> statement, whereas, if I&#x27;d choose to go the standard <code>grep</code> route, it&#x27;d be some chained command with <code>awk</code> and a whole lot of <em>regex</em>.</p><p>Anyways, you can also get started the switch to using (and appreciating) Rust CLI tools, 10/10 recommended. Here&#x27;s a list of some of the ones I&#x27;ve used and liked:</p><ul><li><code>ripgrep</code> &lt;- <code>grep</code></li><li><code>fd</code> &lt;- <code>find</code></li><li><code>exa</code> &lt;- <code>ls</code></li><li><code>bat</code> &lt;- <code>cat</code></li><li><code>procs</code> &lt;- <code>ps</code></li><li><code>du-dust</code> &lt;- <code>du</code></li><li><code>hexyl</code> &lt;- <code>hexdump</code></li><li><code>hyperfine</code> &lt;- <code>time</code></li><li><code>tokei</code> &lt;- <code>wc</code></li><li><code>sd</code> &lt;- <code>sed</code> (not so awesome yet though)</li><li><code>delta</code> &lt;- <code>diff</code></li><li><code>broot</code> &lt;- <code>tree</code></li><li><code>zoxide</code> &lt;- <code>cd</code></li><li><code>zoom</code> &lt;- <code>less</code></li><li><code>grex</code> &lt;- For regex stuff</li></ul><p>Would update this list as I find more.</p><p>Cheers!</p>","scope":{}},"frontMatter":{"wordCount":172,"readingTime":{"text":"1 min read","minutes":0.85,"time":51000,"words":170},"slug":"dont-like-rust-use-some-cli-tools-written-in-it-once","fileName":"dont-like-rust-use-some-cli-tools-written-in-it-once.mdx","title":"Don't like Rust? Use some CLI tools written in it once","date":"2022-10-14","tags":["rust","linux","cli"],"draft":false,"summary":"ðŸ¦€ appreciation era","images":[]}},"prev":{"title":"Engineering the Recruitment Automation System","date":"2022-07-02","tags":["system design","go","product","RAS"],"draft":false,"summary":"Discussed the design and implementational complexity behind the new Recruitment Automation System.","images":[],"slug":"engineering-ras"},"next":{"title":"Backing Up Your Backend: Tips for Building a Functional System","date":"2023-01-02","tags":["system design","go","RAS","guide"],"draft":false,"summary":"A summary of learnings and failings and the loop.","images":[],"slug":"backend101"}},"__N_SSG":true}